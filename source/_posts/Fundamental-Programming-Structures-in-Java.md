---
title: Fundamental Programming Structures in Java
date: 2016-12-28 22:18:05
tags: [Java]
categories : Java
---

## 1、数据类型

　　Java中一共有8种基本类型(primitive type)，其中有4种整型、2种浮点类型、1种用表示Unicode编码的字符单元的字符类型char和1种用于表示真值的boolean类型。
<!--more-->
### 1.1、Java整型

|类型|存储需求|取值范围|
|:---- |:---- | :-------------------- |
|int|4字节|-2 147 483 648 ~ 2 147 483 647(正好超过20亿) |
|short|2字节|-32 768 ~ 32767 |
|long|8字节|-9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807|
　　从Java7开始，加上前缀0b就可以写二进制数。例如，0b1001就是9。还可以为数字字面量加下划线，如用1_000_000表示100万。这些下划线只是为了让人更易读。Java编译器会去除这些下划线。

### 1.2、浮点类型

|类型|存储需求|取值范围|
| :----| :----| :--------------------------  |
|float   |4字节  |大约 ± 3.402 823 47E + 38F(有效位数为6 ~ 7位) |
|double  |8字节  |大约 ± 1.797 693 134 862 315 70E + 308 (有效位数为 15 位) |

## 2、运算符优先级：(同一级别运算符按照从左到右的次序进行计算)

|运算符                                                  |结合性|
| :--------------------------------------------------- |:--------:|
|[ ].( )(方法调用)                                         | 从左向右 |
|!　~　++　\-\-　+(一元运算)　-　(一元运算)()(强制类型转换) new          | 从右向左 |
|*/%                                                     | 从左向右 |
|+　-                                                      | 从左向右 |
|<<　>>　>>>                                               | 从左向右 |
|<　<=　>　>= instanceof                                    | 从左向右 |
|==　!=                                                   | 从左向右 |
|&                                                       | 从左向右 |
|^                                                       | 从左向右 |
|&#124;                                                  | 从左向右 |
|&&                                                      | 从左向右 |
|&#124;&#124;                                            | 从左向右 |
|?:                                                      | 从右向左 |
|=　+=　-=　*=　/=　%=　&=　&#124;=　^=　<<=　>>=　>>>=             | 从右向左 |

## 3、检测字符串是否相等

    s.equals(t);


　　一定不能使用 == 运算符检测两个字符串是否相等！这个运算符只能够确定两个字符串是否放置在同一个位置上。当然，如果字符串放置在同一个位置上，它们必然相等。但是，完全有可能将内容相同的多个字符串的拷贝放置在不同的位置上。

    String greeting = "Hello"; //initialize greeting to a string  
    if(greeting == "Hello") ...  
    // probably true  
    if(greeting.substring(0,3) == "Hel") ...  
    // probably false  

　　如果虚拟机始终将相同的字符串共享，就可以使用==运算符检测是否相等。但实际上只有字符串*常量*是共享的，而 + 或 substring等操作产生的结果并不是共享的。因此，千万不要使用 == 运算符测试字符串的相等性，以免在程序中出现糟糕的bug。

## 4、构建字符串

　　有些时候，需要由较短的字符串构建字符串。采用字符串连接的方式达到此目的的效率比较低。每次连接字符串，都会构建一个新的String对象，即耗时，又浪费空间。使用StringBuilder类就可以避免这个问题的发生。

    StringBuilder builder = new StringBuilder();  
    builder.append(ch); // appends a single character  
    builder.append(str); // appends a string  

　　在需要构建字符串时就调用toString方法，将可以得到一个String对象。

    String completedString = builder.toString();　　//StringBuilder没有重写equals方法。    


　　在JDK5.0中引入StringBuilder类。这个类的前身是StringBuffer，其效率稍有些低，但允许采用多线程的方式执行添加或删除字符的操作。

## 5、格式化输出

　　Java中printf的转换符和标识(包含日期的)用于printf的转换符

### 5.1、用于prinf的转换符

|转换符|类型|举例|
|:-----|:---|:---|
|d|十进制整数|159|
|x|十六进制整数|9f|
|o|八进制整数|237|
|f|定点浮点数|15.9|
|e|指数浮点数|1.59e+01|
|g|通用浮点数|——|
|a|十六进制浮点数|0x1.fccdp3|
|s|字符串|Hello|
|c|字符|H|
|b|布尔|true|
|h|散列码|42628b2|
|tx|日期时间|见下表|
|%|百分号|%|
|n|与平台有关的行分隔符|——|

举例：

    System.out.printf("Hello, %s.　Next year, you'll be %d", name,　age);

### 5.2、用于printf的标志

| 标识 |目的|举例|
| :----------- | :-------------------| :-------------------------|
| +              | 打印正数和负数的符号 |   +3333.33     |
| 空格           | 在正数之前加空格    |   &#124;　3333.33&#124; |
| 0              | 数字之前补0         |   003333.33    |
| -              | 左对齐              |  &#124;3333.33　&#124; |
| (              | 将负数括在括号内     |  (3333.33)     | 
| ,              | 添加分组分隔符       |  3,333.33      | 
| #(用于f格式)    |  包含小数点         |  3,333.        |
| #(对于x或0格式) | 添加前缀0x或0       |   0xcafe       |
| ^              | 转换为大写          |   0xCAFE       |
| $              | 给定被格式化的参数索引。例如， %1\$d, %1\$x将以十进制和十六进制格式打印第一个参数|  159 9F |
| <              | 格式化前面说明的数值。 例如%d%<x以十进制和十六进制打印同一个数值       |  159 9F  |
举例：

    System.out.printf("%,.2f","10000.0./3.0"); 打印3,333.33

### 5.3、日期和时间的转换符

|转换符      |类型                                     |举例
| :--------- |:-------------------| :------------------------------------------------------|
|c           | 完整的日期和时间                         | Mon Feb 09 18:05:11 PST 2004|
|F           | ISO 8061日期                            | 2004-02-09|
|D           | 美国格式的日期                           | 02/09/2004|
|T           | 24小时时间                               | 18:03:23|
|r           | 12小时时间                               | 05:03:23 pm|
|R           | 24小时时间没有秒                         |  18:05|
|Y           | 4位数字的年（前面补0）                    |  2004|
|y           | 年的后两位数字（前面补0）                 |   04|
|C           | 年的前两位数字（前面补0）                 |   20|
|B           | 月的完整拼写                             |   February|
|b或h        | 月的缩写                                |   Feb|
|m           | 两位数字的月（前面补0）                   |   02|
|d           | 两位数字的日（前面补0）                   |   09|
|e           | 两位数字的月（前面不补0）                 |   9|
|A           | 星期几的完整拼写                         |   Monday|
|a           | 星期几的缩写                             |   Mon|
|j           | 三位数的年中的日子（前面补0），在001到366之间|  069|
|H           | 两位数字的小时（前面补0）。在0到23之间        |  18|
|k           | 两位数字的小时（前面不补0）在0到23之间        | 18|
|I           | 两位数字的小时（前面补0）。在0到12之间         | 06|
|1           | 两位数字的小时（前面不补0），在0到12之间       |  6|
|M           | 两位数字的分钟（前面补0）                     | 05|
|S           | 两位数字的秒（前面补0）                       | 19|
|L           | 三位数字的毫秒（前面补0）                     | 047|
|N           | 九位数字的毫微秒（前面补0）                   | 047000000|
|P           | 上午或者下午的大写标志                        |    PM|
|p           | 上午或者下午的小写标志                        | pm|
|z           | 从GMT起。RFC822数字移位                       | -0800|
|Z           | 时区  |PST|
|s           | 从格林威治时间1970-01-01 00:00:00起的秒数  |107884319|
|Q           | 从格林威治时间1970-01-01 00:00:01起的毫秒数 |107884319047|

　　可以采用一个格式化的字符串指出要被格式化的参数索引。索引必须紧跟在%后面，并以$终止。参数索引值从1开始，而不是从0开始。
例如：

    System.out.printf("%1$s %2$tB %2$te, %2$tY","Due date:", new Date());

打印：  Due　Date:　February　9,　2004
还可以选择使用 < 标志。它指示前面格式说明中的参数将被再次使用。也就是说，下列语句将产生与前面语句同样的输出结果：

    System.out.printf("%s %tB %<te, %<tY", "Due Date:", new Date());